<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Malware Development Crash Course</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
  <style>
    .reveal pre code { font-size: 1.05em; }
    .reveal ul, .reveal ol { font-size: 1.1em; }
    .reveal section { font-size: 1.06em; }
  </style>
</head>
<body>
<div class="reveal">
  <div class="slides">

<!-- =========================
    DEL 1: Processer, Trådar, Handles
=========================== -->

<section>
  <h2>Del 1: Processes, Threads, and Handles</h2>
</section>

<section>
  <h3>Förutsättningar för malwareutveckling</h3>
  <ul>
    <li>Lågnivåspråk (C, C++, assembler) ger direkt kontroll över minne & systemanrop</li>
    <li>Oumbärligt för avancerad malware & AV/EDR-bypass</li>
    <li>Python räcker INTE för hands-on manipulation av processer/minne</li>
  </ul>
</section>

<section>
  <h3>Processer i Windows</h3>
  <ul>
    <li>Process = instans av .exe med eget minnesutrymme, kod, resurser & trådar</li>
    <li>Varje process körs isolerat i virtuell adressrymd</li>
    <li>Processer kan starta childprocesser (subprocesser)</li>
  </ul>
</section>

<section>
  <h4>Typer av Windows-processer</h4>
  <ul>
    <li>Applikationsprocesser (t.ex. Word, Chrome, Notepad)</li>
    <li>Bakgrundsprocesser (tjänster, updaterare)</li>
    <li>Windows-processer (OS-kärna, t.ex. csrss.exe, svchost.exe)</li>
  </ul>
  <p style="color:aqua">Många malwaretekniker går ut på att injicera kod i redan existerande, legitima 
    processer (t.ex. explorer.exe) för att gömma sig och undvika upptäckt.</p>
</section>

<section>
  <h3>Processprioritet i Windows</h3>
  <ul>
    <li>Sex nivåer: Real time, High, Above normal, Normal, Below normal, Low</li>
    <li>Påverkar hur mycket CPU-processen får</li>
  </ul>
</section>

<section>
  <h3>Trådar (Threads)</h3>
  <ul>
    <li>Minsta exekveringsenhet i Windows</li>
    <li>Varje process startar med en primär tråd, kan skapa flera</li>
    <li>Trådar är lättviktiga och delar resurser inom processen</li>
  </ul>
</section>

<section>
  <h4>Trådar i offensiv kod</h4>
  <ul>
    <li>Kör flera delar av malware parallellt (t.ex. keylogger + C2)</li>
    <li>Skapa trådar för att gömma aktivitet eller köra tidsstyrda attacker</li>
  </ul>
</section>

<section>
  <h3>Handles</h3>
  <ul>
    <li>“Handtag” till objekt i Windows (process, tråd, fil, modul…)</li>
    <li>Program hanterar resurser via handles istället för direkta minnesadresser</li>
    <li>Mest använda: <code>HANDLE</code> (generiskt), <code>HMODULE</code> (modul/DLL)</li>
  </ul>
</section>

<section>
  <h4>Handles för malware</h4>
  <ul>
    <li>Öppna/förändra andra processer/trådar</li>
    <li>Injicera kod, läsa minne, manipulera objekt</li>
  </ul>
</section>

<section>
  <h3>Win32 API – Gränssnitt mot systemet</h3>
  <ul>
    <li>Bibliotek av funktioner för att interagera med Windows OS</li>
    <li>All klassisk offensiv teknik (injection, hollowing, dumping) bygger på Win32 API</li>
  </ul>
</section>

<section>
  <h3>Hands-on: MessageBox med Win32 API</h3>
  <pre><code class="language-c">#include &lt;windows.h&gt;
int main() {
    MessageBoxA(
        NULL, "Detta är ett exempel på MessageBox!",
        "MalwareDev", MB_OK | MB_ICONINFORMATION
    );
    return 0;
}
</code></pre>
</section>

<section>
  <h3>Hands-on: Starta Notepad-process</h3>
  <pre><code class="language-c">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
int main() {
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);
    if (CreateProcessA(NULL, "notepad.exe", NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        printf("Notepad startades! PID: %u\n", pi.dwProcessId);
        CloseHandle(pi.hProcess); CloseHandle(pi.hThread);
    } else {
        printf("Misslyckades: %lu\n", GetLastError());
    }
    return 0;
}
</code></pre>
</section>

<section>
  <h3>Sammanfattning</h3>
  <ul>
    <li>Förstå processer, trådar & handles = grunden för malwaredev på Windows</li>
    <li>Win32 API = “officiella” vägen för manipulation – används av både legit och malware</li>
  </ul>
</section>

<!-- =========================
    DEL 2: Process/DLL Injection
=========================== -->

<section>
  <h2>Del 2: Process Injection och DLL Injection</h2>
</section>

<section>
  <h3>Förutsättningar & Lab Setup</h3>
  <ul>
    <li>Endast för utbildning/labb – kör i en VM</li>
    <li>Kräver: C/Win32 API, Visual Studio, MSFVenom, Windows + Kali VM</li>
  </ul>
</section>

<section>
  <h3>Vad är process injection?</h3>
  <ul>
    <li>Injicera kod (shellcode/DLL) i en existerande process</li>
    <li>Syften: Gömma sig, privilege escalation, starta en C2a osv</li>
  </ul>
</section>

<section>
  <h3>Shellcode injection – steg för steg</h3>
  <ol>
    <li><b>Öppna process:</b> <code>OpenProcess</code></li>
    <li><b>Allokera minne:</b> <code>VirtualAllocEx</code></li>
    <li><b>Skriv shellcode:</b> <code>WriteProcessMemory</code></li>
    <li><b>Skapa tråd:</b> <code>CreateRemoteThread</code></li>
  </ol>
</section>

<section>
  <h3>Shellcode injection – Exempel</h3>
  <pre><code class="language-c">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
LPVOID addr = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT | 
MEM_RESERVE, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProcess, addr, shellcode, size, NULL);
HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 
(LPTHREAD_START_ROUTINE)addr, NULL, 0, NULL);
</code></pre>
  <p><i>Generera shellcode med <code>msfvenom</code></i></p>
</section>

<section>
  <h3>DLL-injektion – teori & praktik</h3>
  <ol>
    <li>Skriv DLL med <code>DllMain</code> (din payload)</li>
    <li>Hämta handle med <code>OpenProcess</code></li>
    <li>Allokera minne för sökväg (<code>VirtualAllocEx</code>)</li>
    <li>Skriv in sökväg (<code>WriteProcessMemory</code>)</li>
    <li>Få adress till <code>LoadLibraryA</code> (<code>GetModuleHandle</code> + <code>GetProcAddress</code>)</li>
    <li>Skapa tråd (<code>CreateRemoteThread</code>) och peka på <code>LoadLibraryA</code></li>
  </ol>
</section>

<section>
  <h4>Exempel på DLL-kod</h4>
  <pre><code class="language-c">#include &lt;windows.h&gt;
BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        MessageBoxA(NULL, "DLL injected!", "MalwareDev", MB_OK);
    }
    return TRUE;
}
</code></pre>
</section>

<section>
  <h4>Vanliga fallgropar & tips</h4>
  <ul>
    <li>Matcha 32/64-bit mellan all kod & process</li>
    <li>AV/EDR: Klassiska tekniker upptäcks – tänk på obfuskering/kryptering -> mer längre fram</li>
    <li>PROCESS_ALL_ACCESS kräver rättigheter!</li>
  </ul>
</section>

<!-- =========================
    DEL 3: Native API och NT-injektion
=========================== -->

<section>
  <h2>Del 3: Native API och NT-injektion</h2>
</section>

<section>
  <h3>Varför Native API?</h3>
  <ul>
    <li>Win32 API (VirtualAllocEx, WriteProcessMemory, CreateRemoteThread) är välkända och ofta hookade av AV/EDR</li>
    <li>Native API/NT API (funktioner som börjar på <code>Nt*</code>):</li>
    <ul>
      <li>Mindre dokumenterade</li>
      <li>Svårare att hooka på user mode-nivå</li>
      <li>Ger mer “stealth” för malware</li>
    </ul>
  </ul>
</section>

<section>
  <h4>User mode vs Kernel mode</h4>
  <ul>
    <li>User mode (Ring 3): Vanliga program/processer</li>
    <li>Kernel mode (Ring 0): Full access – OS, drivrutiner, AV, EDR</li>
    <li>Access till kernel går via system calls (<b>syscalls</b>)</li>
    <li>Vanligaste flöde:<br>
      <code>Ditt program → Win32 API → kernelbase.dll → ntdll.dll (NT API) → syscall → kernel</code>
    </li>
  </ul>
</section>

<section>
  <h4>ntdll.dll och API-flöde</h4>
  <ul>
    <li>ntdll.dll exporterar alla <code>Nt*</code>-funktioner (Native API)</li>
    <li>Malware kan anropa dem direkt för att slippa många hooks</li>
    <li>Reverse engineering med x64dbg: Följ ett API-anrop till dess syscall!</li>
  </ul>
</section>

<section>
  <h3>Visualisering</h3>
<pre><code>Ditt program
   │
   └─> Win32 API (t.ex. kernel32.dll) – “det du kodar mot”
        │
        └─> kernelbase.dll – fungerar som proxy/lager för API-funktionalitet
            │
            └─> ntdll.dll – Native API (Nt* och Zw*-funktioner)
                │
                └─> syscall-instruktion – växlar från user mode till kernel mode
                    │
                    └─> Windows Kernel – gör själva jobbet</code></pre>
</section>

<section>
  <h3>NT API Injection – Kodexempel (kortad)</h3>
  <pre><code class="language-c">typedef NTSTATUS (NTAPI *pNtOpenProcess)(...);
HMODULE ntdll = GetModuleHandleA("ntdll.dll");
pNtOpenProcess NtOpenProcess = (pNtOpenProcess)GetProcAddress(ntdll, "NtOpenProcess");
// ... Samma logik som vanlig injection, men med NT API-funktioner
</code></pre>
  <p><i>Alla prototyper/strukturer finns i ReactOS-projektet eller Windows headers.</i></p>
</section>

<section>
  <h4>Fördelar & Nackdelar</h4>
  <ul>
    <li>Svårare att upptäcka för AV/EDR (mindre hookat)</li>
    <li>Större risk för instabil kod, mindre dokumentation</li>
    <li>Kräver förståelse för Windows internals & rätt arkitektur (32/64-bit)</li>
  </ul>
</section>

<section>
  <h3>Diskussionsfrågor</h3>
  <ul>
    <li>Vad är största skillnaden mellan NT API och Win32 API ur malware-perspektiv?</li>
    <li>Hur upptäcker man NT API-anrop vid reverse engineering?</li>
  </ul>
  <p><i>Vi är nu inne på väldigt avancerade metoder</i></p>
</section>

<!-- =========================
    DEL 4: Syscalls (Direct/Indirect)
=========================== -->

<section>
  <h2>Del 4: System Calls – Direct och Indirect Syscalls</h2>
</section>

<section>
  <h3>Vad är en system call (syscall)?</h3>
  <ul>
    <li>Lågnivå-sätt att begära kernel-operation (minne, trådar, processer...)</li>
    <li>Normalt: Program → Win32 API → kernelbase.dll → ntdll.dll → syscall → kernel</li>
    <li>Syscall-nummer läggs i <code>eax/rax</code> före instruktionsanrop</li>
  </ul>
</section>

<section>
  <h4>Kernelinternals och SSDT</h4>
  <ul>
    <li>syscall-instruktion gör att CPU hoppar in i kernel (via MSR, ex. IA32_LSTAR)</li>
    <li>Systemanropsnummer används som index i SSDT (System Service Descriptor Table)</li>
    <li>SSDT = tabell med pekare till alla kernel-funktioner</li>
  </ul>
</section>

<section>
  <h4>Direct syscalls</h4>
  <ul>
    <li>Malware bygger egna syscall-stubbar</li>
    <li>Hämtar rätt syscall-nummer, sätter argument, kör <code>syscall</code> direkt (går runt ntdll.dll)</li>
    <li>Bra stealth mot AV/EDR – men kan sticka ut vid dålig implementation</li>
  </ul>
  <pre><code class="language-assembly">mov r10, rcx
mov eax, &lt;syscall_number&gt;
syscall
ret
</code></pre>
  <p>Se: <a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank">SysWhispers2</a></p>
</section>

<section>
  <h4>Indirect syscalls</h4>
  <ul>
    <li>Hoppar direkt in i legitima syscall-stubbar i ntdll.dll</li>
    <li>Går förbi importtabell & API-hooks, men syns utifrån som "vanligt" beteende</li>
    <li>Svårast att upptäcka, men kräver precision</li>
  </ul>
</section>

<section>
  <h4>Direkt/indirekt syscalls – jämförelse</h4>
  <table>
    <tr><th>Teknik</th><th>Stealth</th><th>Nackdelar</th></tr>
    <tr><td>Win32 API</td><td>Låg</td><td>User mode-hooks</td></tr>
    <tr><td>NT API</td><td>Medel</td><td>Fortf. hookbar</td></tr>
    <tr><td>Direct syscall</td><td>Hög</td><td>Kan sticka ut</td></tr>
    <tr><td>Indirect syscall</td><td>Högst</td><td>Kräver precision</td></tr>
  </table>
</section>

<section>
  <h4>Proof of Concept: Kombinera tekniker</h4>
  <ul>
    <li>Avancerad malware använder NT API för det mesta, direct/indirect syscalls för stealth</li>
    <li>Starta processer, allokera minne, skapa trådar – olika metoder i samma verktyg</li>
    <li>Full implementation: använd SysWhispers2 eller Hell’s Gate</li>
  </ul>
</section>
<!-- =========================
    DEL 5: Anti-analys, Anti-debugging & Självdestruktion
=========================== -->

<section>
  <h2>Del 5: Anti-analys, Anti-debugging & Självdestruktion</h2>
</section>

<section>
  <h3>Varför gömma sig?</h3>
  <ul>
    <li>Malware vill undvika upptäckt och analys</li>
    <li>Blue team måste känna igen, patcha eller kringgå dessa tekniker</li>
  </ul>
</section>

<section>
  <h4>Antivirus (AV) vs EDR</h4>
  <ul>
    <li>AV: Signaturbaserad detektion – funkar ej mot ny/polymorf/filfri malware</li>
    <li>Heuristik: Statiska & dynamiska metoder (sandbox, analys)</li>
    <li>EDR: Realtidsanalys av processer, minne, nätverk – upptäcker okända hot</li>
  </ul>
</section>

<section>
  <h3>Anti-debugging-tekniker</h3>
  <ul>
    <li><code>IsDebuggerPresent()</code> – Avsluta program om debugger hittas</li>
    <li>Lågnivå: Läs PEB-&gt;BeingDebugged (PEB/TEB-struktur)</li>
    <li>Direkt läsning undviker klassiska API-hooks</li>
  </ul>
  <pre><code class="language-c">PPEB pPeb = (PPEB)__readgsqword(0x60);
if (pPeb->BeingDebugged) ExitProcess(0);
</code></pre>
</section>

<section>
  <h4>Hur analysteam kringgår anti-debugging</h4>
  <ul>
    <li>Pachar PEB:s <code>BeingDebugged</code> till 0</li>
    <li>Många forensiska/debuggers gör detta automatiskt</li>
  </ul>
</section>

<section>
  <h3>Självdestruktion: Radera sig själv</h3>
  <ul>
    <li>Byt namn på huvudfil till en ADS (Alternate Data Stream)</li>
    <li>Markera huvudfilen för borttagning</li>
    <li>Görs vid upptäckt debugger, misslyckad kodanalys, färdig payload</li>
  </ul>
  <pre><code class="language-c">MoveFile("malware.exe", "malware.exe:old");
DeleteFile("malware.exe"); // Huvudfil kan nu tas bort
</code></pre>
</section>

<section>
  <h4>Sammanfattning och tips</h4>
  <ul>
    <li>Kombinera anti-debugging & självdestruktion för att försvåra analys</li>
    <li>Effektivt för både offensivt och defensivt arbete</li>
    <li>För att motverka: använd memory patching, forensiska verktyg och känn igen ovanliga NTFS/filbeteenden</li>
  </ul>
</section>

<section>
  <h3>Vidare läsning & verktyg</h3>
  <ul>
    <li><a href="https://x64dbg.com/" target="_blank">x64dbg</a> – Debugger med patching/anti-anti-debug-funktioner</li>
    <li><a href="https://learn.microsoft.com/en-us/sysinternals/downloads/streams" target="_blank">Sysinternals Streams</a> – Visa/hantera NTFS ADS</li>
    <li>Microsoft Docs: <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb" target="_blank">PEB/TEB Structures</a></li>
    <li>MalDev Academy, Malware Unicorn, forum & communitys</li>
  </ul>
</section>

  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>Reveal.initialize({ hash: true, slideNumber: true, width:1200, height:900 });hljs.highlightAll();</script>
</body>
</html>
